<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wasm virtual machine specific to the Substrate/Polkadot Runtime Environment."><meta name="keywords" content="rust, rustlang, rust-lang, host"><title>smoldot::executor::host - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings"></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../smoldot/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><p class="location">Module host</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div><p class="location"><a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">executor</a></p><div id="sidebar-vars" data-name="host" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">executor</a>::<wbr><a class="mod" href="">host</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/smoldot/executor/host.rs.html#18-2558" title="goto source code">[src]</a></span></h1><div class="docblock"><p>Wasm virtual machine specific to the Substrate/Polkadot Runtime Environment.</p>
<p>Contrary to <a href="../../../smoldot/executor/vm/struct.VirtualMachine.html"><code>VirtualMachine</code></a>, this code is not just a generic
Wasm virtual machine, but is aware of the Substrate/Polkadot runtime environment. The host
functions that the Wasm code calls are automatically resolved and either handled or notified
to the user of this module.</p>
<p>Any host function that requires pure CPU computations (for example building or verifying
a cryptographic signature) is directly handled by the code in this module. Other host
functions (for example accessing the state or printing a message) are instead handled by
interrupting the virtual machine and waiting for the user of this module to handle the call.</p>
<blockquote>
<p><strong>Note</strong>: The <code>ext_offchain_random_seed_version_1</code> and <code>ext_offchain_timestamp_version_1</code>
functions, which requires the host to respectively produce a random seed and
return the current time, must also be handled by the user. While these functions
could theoretically be handled directly by this module, it might be useful for
testing purposes to have the possibility to return a deterministic value.</p>
</blockquote>
<p>Contrary to most programs, runtime code doesn’t have a singe <code>main</code> or <code>start</code> function.
Instead, it exposes several entry points. Which one to call indicates which action it has to
perform. Not all entry points are necessarily available on all runtimes.</p>
<h1 id="runtime-requirements" class="section-header"><a href="#runtime-requirements">Runtime requirements</a></h1>
<p>See the <a href="../../../smoldot/executor/vm/index.html">documentation of the <code>vm</code> module</a> for details about the requirements a
runtime must adhere to.</p>
<p>In addition to the requirements described there, the WebAssembly runtime code can also be
zstandard-compressed and must also export a global symbol named <code>__heap_base</code>.
More details below.</p>
<h2 id="zstandard-compression" class="section-header"><a href="#zstandard-compression">Zstandard compression</a></h2>
<p>The runtime code passed as parameter to <a href="../../../smoldot/executor/host/struct.HostVmPrototype.html#method.new" title="HostVmPrototype::new"><code>HostVmPrototype::new</code></a> can be compressed using the
<a href="https://en.wikipedia.org/wiki/Zstandard">zstd</a> algorithm.</p>
<p>If the code starts with the magic bytes <code>[82, 188, 83, 118, 70, 219, 142, 5]</code>, then it is
assumed that the rest of the data is a zstandard-compressed WebAssembly module.</p>
<h2 id="memory-allocations" class="section-header"><a href="#memory-allocations">Memory allocations</a></h2>
<p>One of the instructions available in WebAssembly code is
<a href="https://webassembly.github.io/spec/core/bikeshed/#-hrefsyntax-instr-memorymathsfmemorygrow">the <code>memory.grow</code> instruction</a>,
which allows increasing the size of the memory.</p>
<p>WebAssembly code is normally intended to perform its own heap-management logic internally, and
use the <code>memory.grow</code> instruction if more memory is needed.</p>
<p>In order to minimize the size of the runtime binary, and in order to accomodate for the API of
the host functions that return a buffer of variable length, the Substrate/Polkadot runtimes,
however, do not perform their heap management internally. Instead, they use the
<code>ext_allocator_malloc_version_1</code> and <code>ext_allocator_free_version_1</code> host functions for this
purpose. Calling <code>memory.grow</code> is forbidden.</p>
<p>Consequently, the size of the memory available to the WebAssembly virtual machine is always
fixed, and is equal to the initial size of the memory plus the value of <code>heap_pages</code> that is
passed as parameter to <a href="../../../smoldot/executor/host/struct.HostVmPrototype.html#method.new" title="HostVmPrototype::new"><code>HostVmPrototype::new</code></a>.</p>
<p>Additionally, the runtime code must export a global symbol named <code>__heap_base</code> of type <code>i32</code>.
Any memory whose offset is below the value of <code>__heap_base</code> can be used at will by the
program, while any memory above this value is available for use by the implementation of
<code>ext_allocator_malloc_version_1</code>.</p>
<h2 id="entry-points" class="section-header"><a href="#entry-points">Entry points</a></h2>
<p>All entry points that can be called from the host (using, for example,
<a href="../../../smoldot/executor/host/struct.HostVmPrototype.html#method.run" title="HostVmPrototype::run"><code>HostVmPrototype::run</code></a>) have the same signature:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
(<span class="ident">func</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">runtime_entry</span>(<span class="ident">param</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">data</span> <span class="ident">i32</span>) (<span class="ident">param</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">len</span> <span class="ident">i32</span>) (<span class="ident">result</span> <span class="ident">i64</span>))</pre></div>
<p>In order to call into the runtime, one must write a buffer of data containing the input
parameters into the Wasm virtual machine’s memory, then pass a pointer and length of this
buffer as the parameters of the entry point.</p>
<p>The function returns a 64bits number. The 32 less significant bits represent a pointer to the
Wasm virtual machine’s memory, and the 32 most significant bits a length. This pointer and
length designate a buffer containing the actual return value.</p>
<h2 id="host-functions" class="section-header"><a href="#host-functions">Host functions</a></h2>
<p>The list of host functions available to the runtime is long and isn’t documented here. See
the official specifications for details.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>The first step is to create a <a href="../../../smoldot/executor/host/struct.HostVmPrototype.html" title="HostVmPrototype"><code>HostVmPrototype</code></a> object from the WebAssembly code. Creating
this object performs some initial steps, such as parsing and compiling the WebAssembly code.
You are encouraged to maintain a cache of <a href="../../../smoldot/executor/host/struct.HostVmPrototype.html" title="HostVmPrototype"><code>HostVmPrototype</code></a> objects (one instance per
WebAssembly byte code) in order to avoid performing these operations too often.</p>
<p>To start calling the runtime, create a <a href="../../../smoldot/executor/host/enum.HostVm.html" title="HostVm"><code>HostVm</code></a> by calling <a href="../../../smoldot/executor/host/struct.HostVmPrototype.html#method.run" title="HostVmPrototype::run"><code>HostVmPrototype::run</code></a>.</p>
<p>While the Wasm runtime code has side-effects (such as storing values in the storage), the
<a href="../../../smoldot/executor/host/enum.HostVm.html" title="HostVm"><code>HostVm</code></a> itself is a pure state machine with no side effects.</p>
<p>At any given point, you can examine the <a href="../../../smoldot/executor/host/enum.HostVm.html" title="HostVm"><code>HostVm</code></a> in order to know in which state the
execution currently is.
In case of a <a href="../../../smoldot/executor/host/enum.HostVm.html#variant.ReadyToRun" title="HostVm::ReadyToRun"><code>HostVm::ReadyToRun</code></a> (which initially is the case when you create the
<a href="../../../smoldot/executor/host/enum.HostVm.html" title="HostVm"><code>HostVm</code></a>), you can execute the Wasm code by calling <a href="../../../smoldot/executor/host/struct.ReadyToRun.html#method.run" title="ReadyToRun::run"><code>ReadyToRun::run</code></a>.
No background thread of any kind is used, and calling <a href="../../../smoldot/executor/host/struct.ReadyToRun.html#method.run" title="ReadyToRun::run"><code>ReadyToRun::run</code></a> directly performs
the execution of the Wasm code. If you need parallelism, you are encouraged to spawn a
background thread yourself and call this function from there.
<a href="../../../smoldot/executor/host/struct.ReadyToRun.html#method.run" title="ReadyToRun::run"><code>ReadyToRun::run</code></a> tries to make the execution progress as much as possible, and returns
the new state of the virtual machine once that is done.</p>
<p>If the runtime has finished, or has crashed, or wants to perform an operation with side
effects, then the <a href="../../../smoldot/executor/host/enum.HostVm.html" title="HostVm"><code>HostVm</code></a> determines what to do next. For example, for
<a href="../../../smoldot/executor/host/enum.HostVm.html#variant.ExternalStorageGet" title="HostVm::ExternalStorageGet"><code>HostVm::ExternalStorageGet</code></a>, you must load a value from the storage and pass it back by
calling <a href="../../../smoldot/executor/host/struct.ExternalStorageGet.html#method.resume" title="ExternalStorageGet::resume"><code>ExternalStorageGet::resume</code></a>.</p>
<p>The Wasm execution is fully deterministic, and the outcome of the execution only depends on
the inputs. There is, for example, no implicit injection of randomness or of the current time.</p>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">smoldot</span>::<span class="ident">executor</span>::<span class="ident">host</span>::{<span class="ident">HeapPages</span>, <span class="ident">HostVm</span>, <span class="ident">HostVmPrototype</span>};


<span class="comment">// Start executing a function on the runtime.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vm</span>: <span class="ident">HostVm</span> <span class="op">=</span> {
    <span class="kw">let</span> <span class="ident">prototype</span> <span class="op">=</span> <span class="ident">HostVmPrototype</span>::<span class="ident">new</span>(
        <span class="kw-2">&amp;</span><span class="ident">wasm_binary_code</span>,
        <span class="ident">HeapPages</span>::<span class="ident">from</span>(<span class="number">2048</span>),
        <span class="ident">smoldot</span>::<span class="ident">executor</span>::<span class="ident">vm</span>::<span class="ident">ExecHint</span>::<span class="ident">Oneshot</span>
    ).<span class="ident">unwrap</span>();
    <span class="ident">prototype</span>.<span class="ident">run_no_param</span>(<span class="string">&quot;Core_version&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">into</span>()
};

<span class="comment">// We need to answer the calls that the runtime might perform.</span>
<span class="kw">loop</span> {
    <span class="kw">match</span> <span class="ident">vm</span> {
        <span class="comment">// Calling `runner.run()` is what actually executes WebAssembly code and updates</span>
        <span class="comment">// the state.</span>
        <span class="ident">HostVm</span>::<span class="ident">ReadyToRun</span>(<span class="ident">runner</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">runner</span>.<span class="ident">run</span>(),

        <span class="ident">HostVm</span>::<span class="ident">Finished</span>(<span class="ident">finished</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">// `finished.value()` here is an opaque blob of bytes returned by the runtime.</span>
            <span class="comment">// In the case of a call to `&quot;Core_version&quot;`, we know that it must be empty.</span>
            <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">finished</span>.<span class="ident">value</span>().<span class="ident">as_ref</span>().<span class="ident">is_empty</span>());
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Success!&quot;</span>);
            <span class="kw">break</span>;
        },

        <span class="comment">// Errors can happen if the WebAssembly code panics or does something wrong.</span>
        <span class="comment">// In a real-life situation, the host should obviously not panic in these situations.</span>
        <span class="ident">HostVm</span>::<span class="ident">Error</span> { .. } <span class="op">=</span><span class="op">&gt;</span> {
            <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Error while executing code&quot;</span>)
        },

        <span class="comment">// All the other variants correspond to function calls that the runtime might perform.</span>
        <span class="comment">// `ExternalStorageGet` is shown here as an example.</span>
        <span class="ident">HostVm</span>::<span class="ident">ExternalStorageGet</span>(<span class="ident">req</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Runtime requires the storage value at {:?}&quot;</span>, <span class="ident">req</span>.<span class="ident">key</span>().<span class="ident">as_ref</span>());
            <span class="comment">// Injects the value into the virtual machine and updates the state.</span>
            <span class="ident">vm</span> <span class="op">=</span> <span class="ident">req</span>.<span class="ident">resume</span>(<span class="prelude-val">None</span>); <span class="comment">// Just a stub</span>
        }
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">unimplemented</span><span class="macro">!</span>()
    }
}</pre></div>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use vm::<a class="struct" href="../../../smoldot/executor/vm/struct.HeapPages.html" title="struct smoldot::executor::vm::HeapPages">HeapPages</a>;</code></td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.CallRuntimeVersion.html" title="smoldot::executor::host::CallRuntimeVersion struct">CallRuntimeVersion</a></td><td class="docblock-short"><p>Must provide the runtime version obtained by calling the <code>Core_version</code> entry point of a Wasm
blob.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.EndStorageTransaction.html" title="smoldot::executor::host::EndStorageTransaction struct">EndStorageTransaction</a></td><td class="docblock-short"><p>Declares the end of a transaction.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalOffchainStorageSet.html" title="smoldot::executor::host::ExternalOffchainStorageSet struct">ExternalOffchainStorageSet</a></td><td class="docblock-short"><p>Must set the value of the offchain storage.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageAppend.html" title="smoldot::executor::host::ExternalStorageAppend struct">ExternalStorageAppend</a></td><td class="docblock-short"><p>Must load a storage value, treat it as if it was a SCALE-encoded container, and put <code>value</code>
at the end of the container, increasing the number of elements.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageChangesRoot.html" title="smoldot::executor::host::ExternalStorageChangesRoot struct">ExternalStorageChangesRoot</a></td><td class="docblock-short"><p>Must provide the trie root hash of the changes trie.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageClearPrefix.html" title="smoldot::executor::host::ExternalStorageClearPrefix struct">ExternalStorageClearPrefix</a></td><td class="docblock-short"><p>Must remove from the storage all keys which start with a certain prefix.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageGet.html" title="smoldot::executor::host::ExternalStorageGet struct">ExternalStorageGet</a></td><td class="docblock-short"><p>Must provide the value of a storage entry.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageNextKey.html" title="smoldot::executor::host::ExternalStorageNextKey struct">ExternalStorageNextKey</a></td><td class="docblock-short"><p>Must provide the storage key that follows, in lexicographic order, a specific one.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageRoot.html" title="smoldot::executor::host::ExternalStorageRoot struct">ExternalStorageRoot</a></td><td class="docblock-short"><p>Must provide the trie root hash of the storage.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ExternalStorageSet.html" title="smoldot::executor::host::ExternalStorageSet struct">ExternalStorageSet</a></td><td class="docblock-short"><p>Must set the value of a storage entry.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Finished.html" title="smoldot::executor::host::Finished struct">Finished</a></td><td class="docblock-short"><p>Function execution has succeeded. Contains the return value of the call.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.HostVmPrototype.html" title="smoldot::executor::host::HostVmPrototype struct">HostVmPrototype</a></td><td class="docblock-short"><p>Prototype for an <a href="../../../smoldot/executor/host/enum.HostVm.html" title="HostVm"><code>HostVm</code></a>.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.LogEmit.html" title="smoldot::executor::host::LogEmit struct">LogEmit</a></td><td class="docblock-short"><p>Report about a log entry being emitted.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ReadyToRun.html" title="smoldot::executor::host::ReadyToRun struct">ReadyToRun</a></td><td class="docblock-short"><p>Virtual machine is ready to run.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.StartStorageTransaction.html" title="smoldot::executor::host::StartStorageTransaction struct">StartStorageTransaction</a></td><td class="docblock-short"><p>Declares the start of a transaction.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.Error.html" title="smoldot::executor::host::Error enum">Error</a></td><td class="docblock-short"><p>Reason why the Wasm blob isn’t conforming to the runtime environment.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.HostVm.html" title="smoldot::executor::host::HostVm enum">HostVm</a></td><td class="docblock-short"><p>Running virtual machine.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.ModuleFormatError.html" title="smoldot::executor::host::ModuleFormatError enum">ModuleFormatError</a></td><td class="docblock-short"><p>Error possibly returned when decoding a zstd-compressed Wasm blob.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.NewErr.html" title="smoldot::executor::host::NewErr enum">NewErr</a></td><td class="docblock-short"><p>Error that can happen when initializing a VM.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.StartErr.html" title="smoldot::executor::host::StartErr enum">StartErr</a></td><td class="docblock-short"><p>Error that can happen when starting a VM.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="smoldot" data-search-js="../../../search-index.js"></div>
    <script src="../../../main.js"></script></body></html>